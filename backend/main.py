from fastapi import FastAPI, UploadFile, Form, File, HTTPException, Depends, Body
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from typing import Dict, Any
from pydantic import BaseModel
import random
import fitz  # PyMuPDF

# Import your new DB modules
from lib.gemini_parser import parse_resume_with_gemini
from lib.database import engine, get_db, Base
from lib.models import User

# Create tables automatically (for dev/POC)
Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="FairMatch API",
    description="Backend API",
    version="0.02",
)

# Configuration CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"],  # Frontend Next.js
    allow_credentials=True,
    allow_methods=["*"],  # Permet toutes les méthodes (GET, POST, PUT, DELETE, OPTIONS, etc.)
    allow_headers=["*"],  # Permet tous les headers
)

# -------------------------
# Root endpoint (healthcheck)
# -------------------------
@app.get("/")
def root():
    return {
        "status": "ok",
        "message": "FairMatch API is running",
        "version": "1.0",
    }


# -------------------------
# Fake job catalogue (mock data)
# -------------------------
MOCK_JOBS = [
    {
        "job_id": 101,
        "title": "Junior Data Scientist",
        "company": "TechNova",
        "location": "Paris, France",
        "salary_range": "40–50k",
        "skills": ["Python", "Pandas", "Machine Learning"],
    },
    {
        "job_id": 87,
        "title": "Backend Developer",
        "company": "SoftBridge",
        "location": "Lyon, France",
        "salary_range": "38–48k",
        "skills": ["Python", "FastAPI", "PostgreSQL"],
    },
    {
        "job_id": 203,
        "title": "Machine Learning Intern",
        "company": "InnovaLab",
        "location": "Remote",
        "salary_range": "Internship",
        "skills": ["Python", "Scikit-learn", "Git"],
    },
    {
        "job_id": 56,
        "title": "Cloud Engineer (Entry Level)",
        "company": "SkyNetix",
        "location": "Marseille, France",
        "salary_range": "42–52k",
        "skills": ["AWS", "Docker", "Linux"],
    },
    {
        "job_id": 149,
        "title": "AI Research Assistant",
        "company": "DeepVision",
        "location": "Nice, France",
        "salary_range": "45–55k",
        "skills": ["PyTorch", "Deep Learning", "NLP"],
    },
]


# -------------------------
# Recommendation endpoint
# -------------------------
@app.get("/recommend/{user_id}")
def recommend(user_id: int) -> Dict[str, Any]:
    """
    Returns a random mock job recommendation for the given user_id.
    In Week 3 this will be replaced by the real model.
    """

    # choisir 3 jobs aléatoires dans la liste
    recommended_jobs = random.sample(MOCK_JOBS, k=3)

    response = {
        "user_id": user_id,
        "num_recommendations": len(recommended_jobs),
        "recommendations": recommended_jobs,
        "note": "Mock data only. Real recommendations will be generated by the model in Week 3.",
    }
    return response


@app.post("/api/parse-resume")
async def parse_resume(
    file: UploadFile = File(...),
    name: str = Form(...),
    gender: str = Form(...),
    interested_domain: str = Form(...),
):
    """
    Parse le CV et retourne les données extraites SANS les sauvegarder.
    L'utilisateur pourra les modifier avant de valider.
    """
    # 1. Validate File
    if file.content_type != "application/pdf":
        raise HTTPException(status_code=400, detail="File must be a PDF")
    
    # 2. Extract Text
    try:
        pdf_bytes = await file.read()
        doc = fitz.open(stream=pdf_bytes, filetype="pdf")
        text = "".join([page.get_text() for page in doc])
    except Exception:
        raise HTTPException(status_code=500, detail="Could not read PDF")

    # 3. AI Parsing
    parsed_data = parse_resume_with_gemini(text, interested_domain)
    
    if not parsed_data:
        raise HTTPException(status_code=500, detail="AI parsing failed")

    # 4. Ajouter les informations manuelles aux données parsées
    parsed_data["name"] = name
    parsed_data["gender"] = gender
    parsed_data["interested_domain"] = interested_domain
    
    # 5. Retourner les données parsées (sans sauvegarder)
    return {
        "status": "success",
        "data": parsed_data
    }


@app.post("/api/save-user-profile")
async def save_user_profile(
    profile_data: Dict[str, Any] = Body(...),
    db: Session = Depends(get_db)
):
    """
    Sauvegarde le profil utilisateur après validation des données modifiées.
    """
    try:
        # Vérifier si l'utilisateur existe déjà (par email si fourni)
        existing_user = None
        if profile_data.get("email"):
            existing_user = db.query(User).filter(User.email == profile_data["email"]).first()
        
        # Préparer les données pour la sauvegarde
        user_data = {
            "name": profile_data.get("name", ""),
            "gender": profile_data.get("gender", ""),
            "interested_domain": profile_data.get("interested_domain", ""),
            "surname": profile_data.get("surname", ""),
            "email": profile_data.get("email", ""),
            "phone": profile_data.get("phone", ""),
            "address": profile_data.get("address", ""),
            "description": profile_data.get("description", ""),
            "age": profile_data.get("age") or profile_data.get("Age"),
            "projects": profile_data.get("projects") or profile_data.get("Projects", []),
            "future_career": profile_data.get("future_career") or profile_data.get("Future_Career", ""),
            "hard_skills": profile_data.get("hard_skills") or profile_data.get("Hard_Skills", []),
            "python_level": profile_data.get("python_level") or profile_data.get("Python_Level", "Weak"),
            "sql_level": profile_data.get("sql_level") or profile_data.get("SQL_Level", "Weak"),
            "java_level": profile_data.get("java_level") or profile_data.get("Java_Level", "Weak"),
            "soft_skills": profile_data.get("soft_skills") or profile_data.get("Soft_Skills", []),
            "languages": profile_data.get("languages") or profile_data.get("Languages", []),
            "education": profile_data.get("education") or profile_data.get("Education", []),
            "work_experience": profile_data.get("work_experience") or profile_data.get("Work_Experience", []),
            "certifications": profile_data.get("certifications") or profile_data.get("Certifications", []),
            "interests": profile_data.get("interests") or profile_data.get("Interests", []),
        }
        
        if existing_user:
            # Mettre à jour l'utilisateur existant
            for key, value in user_data.items():
                setattr(existing_user, key, value)
            db.commit()
            db.refresh(existing_user)
            return {
                "status": "updated",
                "user_id": existing_user.id,
                "message": "Profil mis à jour avec succès"
            }
        else:
            # Créer un nouvel utilisateur
            new_user = User(**user_data)
            db.add(new_user)
            db.commit()
            db.refresh(new_user)
            return {
                "status": "created",
                "user_id": new_user.id,
                "message": "Profil créé avec succès"
            }
    
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Erreur lors de la sauvegarde: {str(e)}")


@app.get("/api/user-profile/{user_id}")
def get_user_profile(user_id: int, db: Session = Depends(get_db)):
    """Récupère le profil d'un utilisateur par son ID"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    return {
        "id": user.id,
        "name": user.name,
        "surname": user.surname,
        "email": user.email,
        "phone": user.phone,
        "address": user.address,
        "gender": user.gender,
        "interested_domain": user.interested_domain,
        "description": user.description,
        "age": user.age,
        "projects": user.projects,
        "future_career": user.future_career,
        "hard_skills": user.hard_skills,
        "python_level": user.python_level,
        "sql_level": user.sql_level,
        "java_level": user.java_level,
        "soft_skills": user.soft_skills,
        "languages": user.languages,
        "education": user.education,
        "work_experience": user.work_experience,
        "certifications": user.certifications,
        "interests": user.interests,
    }


@app.get("/api/user-profile-by-email/{email}")
def get_user_profile_by_email(email: str, db: Session = Depends(get_db)):
    """Récupère le profil d'un utilisateur par son email"""
    user = db.query(User).filter(User.email == email).first()
    if not user:
        # Retourner un objet vide si l'utilisateur n'existe pas encore
        return {
            "id": None,
            "name": "",
            "surname": "",
            "email": email,
            "phone": "",
            "address": "",
            "gender": "",
            "interested_domain": "",
            "description": "",
            "age": None,
            "projects": [],
            "future_career": "",
            "hard_skills": [],
            "python_level": "Weak",
            "sql_level": "Weak",
            "java_level": "Weak",
            "soft_skills": [],
            "languages": [],
            "education": [],
            "work_experience": [],
            "certifications": [],
            "interests": [],
        }
    
    return {
        "id": user.id,
        "name": user.name or "",
        "surname": user.surname or "",
        "email": user.email or email,
        "phone": user.phone or "",
        "address": user.address or "",
        "gender": user.gender or "",
        "interested_domain": user.interested_domain or "",
        "description": user.description or "",
        "age": user.age,
        "projects": user.projects or [],
        "future_career": user.future_career or "",
        "hard_skills": user.hard_skills or [],
        "python_level": user.python_level or "Weak",
        "sql_level": user.sql_level or "Weak",
        "java_level": user.java_level or "Weak",
        "soft_skills": user.soft_skills or [],
        "languages": user.languages or [],
        "education": user.education or [],
        "work_experience": user.work_experience or [],
        "certifications": user.certifications or [],
        "interests": user.interests or [],
    }